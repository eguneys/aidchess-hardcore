var O=Object.defineProperty;var E=(r,e,t)=>e in r?O(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var f=(r,e,t)=>(E(r,typeof e!="symbol"?e+"":e,t),t);import{N as w,i as $,F as v,C as b,a as N,l as C}from"./chess-ece2668e.js";const F=r=>r!==void 0,I=r=>{const e={get:t=>r.getItem(t),set:(t,o)=>r.setItem(t,o),remove:t=>r.removeItem(t),make:t=>({get:()=>e.get(t),set:o=>e.set(t,o),remove:()=>e.remove(t)}),makeBoolean:t=>({get:()=>e.get(t)=="1",set:o=>e.set(t,o?"1":"0"),toggle:()=>e.set(t,e.get(t)=="1"?"0":"1")})};return e},x=I(window.localStorage),W=(r,e)=>t=>{if(F(t))return x.set(r,JSON.stringify(t)),t;const o=JSON.parse(x.get(r));return o!==null?o:e()},p=(r,e)=>r.move(e,{sloppy:!0})||r.move("O-O")||r.move("O-O-O"),_=class{constructor(){f(this,"root")}get flat_export(){return v.apply(this.root)}get clone(){let e=new _;return e.root=this.root.clone,e}node_at_path(e){return this.root.node_at_path_or_undefined(e)}moves(){let[e,t]=v.apply(this.root);return t.map(([o,s])=>{let[a,...h]=this.root.node_list(o),i=new b(a.fen);h.forEach(u=>p(i,u.uci));let l=i.history(),m=l[l.length-1];return`${o} ${m} {${s.comment??""}}`})}chess(e){let[t,...o]=this.root.node_list(e),s=new b(t.fen);return o.forEach(a=>p(s,a.uci)),s}fen(e){return this.chess(e).fen()}add_move(e,t,o){let s=this.chess(e),a=p(s,t),h=`${a.from}${a.to}`,i=s.fen(),l=w.make_branch(i,h,o);return this.root.add_node(l,e)}delete_siblings(e){this.root.delete_siblings(e)}delete_children(e){this.root.delete_children(e)}delete_path(e){let t=N(e),o=C(e);this.root.delete_after(t,o)}delete_variation(e){let[t,...o]=this.root.node_list(e);if(o.length===0)return;let s=o[o.length-1].id;for(let i=o.length-2;i>=0;i--){let l=o[i];if(l.children.length>1)break;s=l.id+s}let a=e.slice(0,-s.length),h=s.slice(0,2);return this.root.delete_after(a,h),a}};let c=_;f(c,"diff_trees",(e,t)=>{let[o,s]=e.flat_export,[a,h]=t.flat_export,i=[],l=[];s.forEach(([n,d])=>{h.find(g=>g[0]===n)||i.push(n)}),h.forEach(([n,d])=>{s.find(g=>g[0]===n)||l.push(n)});let m=[],u=[];return i.forEach(n=>{i.find(d=>d.length<n.length&&n.startsWith(d))||m.push(n)}),l.forEach(n=>{l.find(d=>d.length<n.length&&n.startsWith(d))||u.push(n)}),[m,u]}),f(c,"make",(e=$)=>{let t=new _;return t.root=w.make_root(e),t}),f(c,"flat_doc",e=>{let t=new _;return t.root=v.read(e),t});export{c as R,W as s};
